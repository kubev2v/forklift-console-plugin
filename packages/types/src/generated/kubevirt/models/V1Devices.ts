/* tslint:disable */
/* eslint-disable */
/**
 * KubeVirt API
 * This is KubeVirt API an add-on for Kubernetes.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: kubevirt-dev@googlegroups.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../../runtime';
import type { V1Disk } from './V1Disk';
import {
    V1DiskFromJSON,
    V1DiskFromJSONTyped,
    V1DiskToJSON,
} from './V1Disk';
import type { V1Filesystem } from './V1Filesystem';
import {
    V1FilesystemFromJSON,
    V1FilesystemFromJSONTyped,
    V1FilesystemToJSON,
} from './V1Filesystem';
import type { V1GPU } from './V1GPU';
import {
    V1GPUFromJSON,
    V1GPUFromJSONTyped,
    V1GPUToJSON,
} from './V1GPU';
import type { V1HostDevice } from './V1HostDevice';
import {
    V1HostDeviceFromJSON,
    V1HostDeviceFromJSONTyped,
    V1HostDeviceToJSON,
} from './V1HostDevice';
import type { V1Input } from './V1Input';
import {
    V1InputFromJSON,
    V1InputFromJSONTyped,
    V1InputToJSON,
} from './V1Input';
import type { V1Interface } from './V1Interface';
import {
    V1InterfaceFromJSON,
    V1InterfaceFromJSONTyped,
    V1InterfaceToJSON,
} from './V1Interface';
import type { V1SoundDevice } from './V1SoundDevice';
import {
    V1SoundDeviceFromJSON,
    V1SoundDeviceFromJSONTyped,
    V1SoundDeviceToJSON,
} from './V1SoundDevice';
import type { V1TPMDevice } from './V1TPMDevice';
import {
    V1TPMDeviceFromJSON,
    V1TPMDeviceFromJSONTyped,
    V1TPMDeviceToJSON,
} from './V1TPMDevice';
import type { V1Watchdog } from './V1Watchdog';
import {
    V1WatchdogFromJSON,
    V1WatchdogFromJSONTyped,
    V1WatchdogToJSON,
} from './V1Watchdog';

/**
 * 
 * @export
 * @interface V1Devices
 */
export interface V1Devices {
    /**
     * Whether to attach the default graphics device or not. VNC will not be available if set to false. Defaults to true.
     * @type {boolean}
     * @memberof V1Devices
     */
    autoattachGraphicsDevice?: boolean;
    /**
     * Whether to attach an Input Device. Defaults to false.
     * @type {boolean}
     * @memberof V1Devices
     */
    autoattachInputDevice?: boolean;
    /**
     * Whether to attach the Memory balloon device with default period. Period can be adjusted in virt-config. Defaults to true.
     * @type {boolean}
     * @memberof V1Devices
     */
    autoattachMemBalloon?: boolean;
    /**
     * Whether to attach a pod network interface. Defaults to true.
     * @type {boolean}
     * @memberof V1Devices
     */
    autoattachPodInterface?: boolean;
    /**
     * Whether to attach the default virtio-serial console or not. Serial console access will not be available if set to false. Defaults to true.
     * @type {boolean}
     * @memberof V1Devices
     */
    autoattachSerialConsole?: boolean;
    /**
     * Whether to attach the VSOCK CID to the VM or not. VSOCK access will be available if set to true. Defaults to false.
     * @type {boolean}
     * @memberof V1Devices
     */
    autoattachVSOCK?: boolean;
    /**
     * Whether or not to enable virtio multi-queue for block devices. Defaults to false.
     * @type {boolean}
     * @memberof V1Devices
     */
    blockMultiQueue?: boolean;
    /**
     * Represent a subset of client devices that can be accessed by VMI. At the moment only, USB devices using Usbredir's library and tooling. Another fit would be a smartcard with libcacard.
     * 
     * The struct is currently empty as there is no immediate request for user-facing APIs. This structure simply turns on USB redirection of UsbClientPassthroughMaxNumberOf devices.
     * @type {object}
     * @memberof V1Devices
     */
    clientPassthrough?: object;
    /**
     * DisableHotplug disabled the ability to hotplug disks.
     * @type {boolean}
     * @memberof V1Devices
     */
    disableHotplug?: boolean;
    /**
     * Disks describes disks, cdroms and luns which are connected to the vmi.
     * @type {Array<V1Disk>}
     * @memberof V1Devices
     */
    disks?: Array<V1Disk>;
    /**
     * 
     * @type {object}
     * @memberof V1Devices
     */
    downwardMetrics?: object;
    /**
     * Filesystems describes filesystem which is connected to the vmi.
     * @type {Array<V1Filesystem>}
     * @memberof V1Devices
     */
    filesystems?: Array<V1Filesystem>;
    /**
     * Whether to attach a GPU device to the vmi.
     * @type {Array<V1GPU>}
     * @memberof V1Devices
     */
    gpus?: Array<V1GPU>;
    /**
     * Whether to attach a host device to the vmi.
     * @type {Array<V1HostDevice>}
     * @memberof V1Devices
     */
    hostDevices?: Array<V1HostDevice>;
    /**
     * Inputs describe input devices
     * @type {Array<V1Input>}
     * @memberof V1Devices
     */
    inputs?: Array<V1Input>;
    /**
     * Interfaces describe network interfaces which are added to the vmi.
     * @type {Array<V1Interface>}
     * @memberof V1Devices
     */
    interfaces?: Array<V1Interface>;
    /**
     * Whether to log the auto-attached default serial console or not. Serial console logs will be collect to a file and then streamed from a named `guest-console-log`. Not relevant if autoattachSerialConsole is disabled. Defaults to cluster wide setting on VirtualMachineOptions.
     * @type {boolean}
     * @memberof V1Devices
     */
    logSerialConsole?: boolean;
    /**
     * If specified, virtual network interfaces configured with a virtio bus will also enable the vhost multiqueue feature for network devices. The number of queues created depends on additional factors of the VirtualMachineInstance, like the number of guest CPUs.
     * @type {boolean}
     * @memberof V1Devices
     */
    networkInterfaceMultiqueue?: boolean;
    /**
     * Rng represents the random device passed from host
     * @type {object}
     * @memberof V1Devices
     */
    rng?: object;
    /**
     * 
     * @type {V1SoundDevice}
     * @memberof V1Devices
     */
    sound?: V1SoundDevice;
    /**
     * 
     * @type {V1TPMDevice}
     * @memberof V1Devices
     */
    tpm?: V1TPMDevice;
    /**
     * Fall back to legacy virtio 0.9 support if virtio bus is selected on devices. This is helpful for old machines like CentOS6 or RHEL6 which do not understand virtio_non_transitional (virtio 1.0).
     * @type {boolean}
     * @memberof V1Devices
     */
    useVirtioTransitional?: boolean;
    /**
     * 
     * @type {V1Watchdog}
     * @memberof V1Devices
     */
    watchdog?: V1Watchdog;
}

/**
 * Check if a given object implements the V1Devices interface.
 */
export function instanceOfV1Devices(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function V1DevicesFromJSON(json: any): V1Devices {
    return V1DevicesFromJSONTyped(json, false);
}

export function V1DevicesFromJSONTyped(json: any, ignoreDiscriminator: boolean): V1Devices {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'autoattachGraphicsDevice': !exists(json, 'autoattachGraphicsDevice') ? undefined : json['autoattachGraphicsDevice'],
        'autoattachInputDevice': !exists(json, 'autoattachInputDevice') ? undefined : json['autoattachInputDevice'],
        'autoattachMemBalloon': !exists(json, 'autoattachMemBalloon') ? undefined : json['autoattachMemBalloon'],
        'autoattachPodInterface': !exists(json, 'autoattachPodInterface') ? undefined : json['autoattachPodInterface'],
        'autoattachSerialConsole': !exists(json, 'autoattachSerialConsole') ? undefined : json['autoattachSerialConsole'],
        'autoattachVSOCK': !exists(json, 'autoattachVSOCK') ? undefined : json['autoattachVSOCK'],
        'blockMultiQueue': !exists(json, 'blockMultiQueue') ? undefined : json['blockMultiQueue'],
        'clientPassthrough': !exists(json, 'clientPassthrough') ? undefined : json['clientPassthrough'],
        'disableHotplug': !exists(json, 'disableHotplug') ? undefined : json['disableHotplug'],
        'disks': !exists(json, 'disks') ? undefined : ((json['disks'] as Array<any>).map(V1DiskFromJSON)),
        'downwardMetrics': !exists(json, 'downwardMetrics') ? undefined : json['downwardMetrics'],
        'filesystems': !exists(json, 'filesystems') ? undefined : ((json['filesystems'] as Array<any>).map(V1FilesystemFromJSON)),
        'gpus': !exists(json, 'gpus') ? undefined : ((json['gpus'] as Array<any>).map(V1GPUFromJSON)),
        'hostDevices': !exists(json, 'hostDevices') ? undefined : ((json['hostDevices'] as Array<any>).map(V1HostDeviceFromJSON)),
        'inputs': !exists(json, 'inputs') ? undefined : ((json['inputs'] as Array<any>).map(V1InputFromJSON)),
        'interfaces': !exists(json, 'interfaces') ? undefined : ((json['interfaces'] as Array<any>).map(V1InterfaceFromJSON)),
        'logSerialConsole': !exists(json, 'logSerialConsole') ? undefined : json['logSerialConsole'],
        'networkInterfaceMultiqueue': !exists(json, 'networkInterfaceMultiqueue') ? undefined : json['networkInterfaceMultiqueue'],
        'rng': !exists(json, 'rng') ? undefined : json['rng'],
        'sound': !exists(json, 'sound') ? undefined : V1SoundDeviceFromJSON(json['sound']),
        'tpm': !exists(json, 'tpm') ? undefined : V1TPMDeviceFromJSON(json['tpm']),
        'useVirtioTransitional': !exists(json, 'useVirtioTransitional') ? undefined : json['useVirtioTransitional'],
        'watchdog': !exists(json, 'watchdog') ? undefined : V1WatchdogFromJSON(json['watchdog']),
    };
}

export function V1DevicesToJSON(value?: V1Devices | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'autoattachGraphicsDevice': value.autoattachGraphicsDevice,
        'autoattachInputDevice': value.autoattachInputDevice,
        'autoattachMemBalloon': value.autoattachMemBalloon,
        'autoattachPodInterface': value.autoattachPodInterface,
        'autoattachSerialConsole': value.autoattachSerialConsole,
        'autoattachVSOCK': value.autoattachVSOCK,
        'blockMultiQueue': value.blockMultiQueue,
        'clientPassthrough': value.clientPassthrough,
        'disableHotplug': value.disableHotplug,
        'disks': value.disks === undefined ? undefined : ((value.disks as Array<any>).map(V1DiskToJSON)),
        'downwardMetrics': value.downwardMetrics,
        'filesystems': value.filesystems === undefined ? undefined : ((value.filesystems as Array<any>).map(V1FilesystemToJSON)),
        'gpus': value.gpus === undefined ? undefined : ((value.gpus as Array<any>).map(V1GPUToJSON)),
        'hostDevices': value.hostDevices === undefined ? undefined : ((value.hostDevices as Array<any>).map(V1HostDeviceToJSON)),
        'inputs': value.inputs === undefined ? undefined : ((value.inputs as Array<any>).map(V1InputToJSON)),
        'interfaces': value.interfaces === undefined ? undefined : ((value.interfaces as Array<any>).map(V1InterfaceToJSON)),
        'logSerialConsole': value.logSerialConsole,
        'networkInterfaceMultiqueue': value.networkInterfaceMultiqueue,
        'rng': value.rng,
        'sound': V1SoundDeviceToJSON(value.sound),
        'tpm': V1TPMDeviceToJSON(value.tpm),
        'useVirtioTransitional': value.useVirtioTransitional,
        'watchdog': V1WatchdogToJSON(value.watchdog),
    };
}

